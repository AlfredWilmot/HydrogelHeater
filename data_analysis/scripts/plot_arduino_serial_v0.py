# -*- coding: utf-8 -*-
#!/usr/bin/env python

"""
Created on Tue Dec 15 14:39:35 2020

@author: alfred

references:
    (pyserial)
    > https://pythonpedia.com/en/tutorial/5744/python-serial-communication-pyserial-
    > https://pyserial.readthedocs.io/en/latest/pyserial.html
    
    (plotting)
    > https://www.youtube.com/watch?v=PlL2cT3rzTg
    
"""

import serial
import serial.tools.list_ports as port_list
import sys
import struct

import matplotlib.pyplot as plt

## NOTE: Make sure to install TexLive (I'm using Windows) or this will cause the program to crash --> https://tug.org/texlive/windows.html
# should really check whether the TEX stuff can be seen on the PATH, but I am too lazy to implement that.
#plt.rc('text', usetex=True) #


import numpy as np
import time



'''
Helper function for controlling the lengths of arrays used for plotting.
'''  
def push_to_buffer(buff, buff_len ,val_to_push):
    
    # Adding the serially-received data to the relevant arrays for plotting
    buff.append(val_to_push)
    
    # Ensuring the arrays don't exceed their designated length (can only be as long as the graph is wide). 
    # In this way the arrays behave like FIFO buffers.
    if len(buff) > buff_len:
        del(buff[0])
    
    # This is very lazy and probably going to bite me in the arse, but fuck it
    if buff[0] == 0.0:
        del(buff[0])


'''
This is where the magic happens!
'''
def main():
    
    # Gathers a list of available comports
    ports = list(port_list.comports())
    
    
    '''
    Look through available serial ports and attempt to connect to them sequentially.
    Exits cleanly if unable to find a viable port after exhausting all availablle int hte list
    '''
    for p in ports:

        try:
            print ("Attempting to connect to: " + str(p.device))
            
            s = serial.Serial()
            s.port = str(p.device)
            s.baudrate = 9600
            s.timeout = 1
            s.open()
            
        except:
            print("Could not connect to comport")
            
            if p == ports[-1]:
                print("No more available comports to connect to, exiting program.")
                #sys.exit()
                return -1
     
        
    '''
    Setup the plot stuff 
    '''
    plt.close('all')
    plt.figure()
    plt.ion()
    
    inspct_plt = plt.subplot(221)
    global_plt = plt.subplot(212)
    analyt_plt = plt.subplot(222)
    
    plt.show()

    
    # Arrays for plotting the data coming in from the serial interface with the temperature controller.
    
    # Data shown on the "close-up" view graph
    sp_data_closeUp   = [] 
    msrd_data_closeUp = []

    # Data shown on the "global view" graph
    sp_data_global    = []
    msrd_data_global  = []
    
    # Data for analytics
    drv_data = []
    err_data = []
    
    # Plotting variables:
    closeUpView_len = 10    # The number of samples shown on the "close-up view" plot.
    globalView_len  = 1000  # The number of samples shown on the "global view" plot.
    #view_window_gap = 0.25  # The viewing window gap around the observed values (eg. 0.25 => the window border is 25% wider than the measured vals)
    
    # Hysteresis values (manually copied over from Arduino controller code; make sure they match the latest values!)
    # Draw horizontal lines for these in the "close-up" view (change color to indicate when within outer & err hyst bands)
    err_hyst            = 0.1
    outer_hyst          = 1.0
    dilated_outer_hyst  = 1.5
    
    
    
    '''
    Main loop: reads serial data, and plots it.
    '''
    while s.isOpen():
        
        try:
                            
            # The controller set-point defined by the user via the rotary-encoder input.
            target_temp = s.readline()
            target_temp.decode()
    
            
            # The temperature measured by whichever sensor is selected.
            measured_temp = s.readline()
            measured_temp.decode()
    
            
            # The driving signal generated by the control-loop
            driving_signal = s.readline()
            driving_signal.decode()


            
            #check if a plot is present (if not, user has closed it; so exit the application)
            if plt.fignum_exists(1):

                 # clear the plot so that only one is rendered at a time.
                inspct_plt.cla()
                analyt_plt.cla()
                global_plt.cla()
                
                
                # set the title of the plot
                inspct_plt.set_title("Latest " + str(closeUpView_len) + " values")
                global_plt.set_title("Global-view")
                analyt_plt.set_title("Analytics")
                

                '''
                Plotting the "close-up view"
                '''
                
                # Limiting the length of the relevant arrays for the "close-up view" of the data.
                push_to_buffer(buff=sp_data_closeUp, 
                               buff_len=closeUpView_len, 
                               val_to_push=float(target_temp))
                
                push_to_buffer(buff=msrd_data_closeUp, 
                               buff_len=closeUpView_len, 
                               val_to_push=float(measured_temp))
                                    
                
                # TODO: this should reflect the time-step (presently just a counter of the incoming readings)
                inspct_plt.margins(x=0, y=0.3)

                
                # Plot the measured value against the set-point value
                inspct_plt.plot(sp_data_closeUp, 'r')
                inspct_plt.plot(msrd_data_closeUp, 'b')

                
                # Text to be displayed on the graph
                inspct_plt.legend(["set-point", "measured temp"])
                
                #err = abs(float(target_temp) - float(measured_temp))
                #plt.text(length*0.9, max_val*0.9, "err: " + "{0:.2f}".format(err) + "C")
                
                
                
                '''
                Plotting the "Global view"
                '''                
                # Limiting the length of the relevant arrays for the "global view" of the data.
                push_to_buffer(buff=sp_data_global, 
                               buff_len=globalView_len, 
                               val_to_push=float(target_temp))
                
                push_to_buffer(buff=msrd_data_global, 
                               buff_len=globalView_len, 
                               val_to_push=float(measured_temp))               
  
                global_plt.margins(x=0, y=0.3)
                global_plt.plot(sp_data_global, 'r')
                global_plt.plot(msrd_data_global, 'b')
                global_plt.legend(["set-point", "measured temp"])               
                
                
                
                
                '''
                Plotting the "data analytics" view
                '''
                
                err = float(target_temp) - float(measured_temp)
                
                push_to_buffer(buff=err_data, 
                               buff_len=globalView_len, 
                               val_to_push= err)
                
                analyt_plt.margins(x=0,y=0.3)
                analyt_plt.plot(err_data, color="orange")
                
                avg_err = 0
                
                if len(err_data) < closeUpView_len:
                    avg_err = sum(err_data)/len(err_data)
                else:  
                    avg_err = sum(err_data[-closeUpView_len:-1])/closeUpView_len
                
                analyt_plt.legend(["Avg err over " + str(closeUpView_len) + " samples: " + "{0:.2f}".format(avg_err)])
                
                
                
                
                
                '''
                Housekeeping after servicing all the plots
                '''
                # Give matplot lib some time to render the plot.
                plt.pause(0.01) 
                
            else:
                print("user closed plot, exiting.")
                s.close()
                #sys.exit()
                return 0
            
            
            # Get rid of values accumulated in the buffer while the plot was rendering: want to plot the latest values.
            s.flushInput()  
            
        except KeyboardInterrupt:
            print("Keyboard interrupt, exiting the program")
            plt.close()
            s.close()
            #sys.exit()
            return -1
        
        except PermissionError:
            print("Device disconnected, exiting program")
            plt.close()
            s.close()
            return -1
        
        
        except Exception as e:
             print(str(e))
             
                       
        
        
    
    return 0

if __name__ == '__main__':
    main()
    
    
    
    
    
    

